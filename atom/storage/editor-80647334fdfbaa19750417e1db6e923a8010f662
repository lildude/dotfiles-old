{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1440,"height":873,"maximized":true},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"paths":["/Users/lildude/github/backup-utils"],"buffers":[{"text":"#!/bin/sh\n#/ Usage: ghe-restore [-v] [-s <snapshot-id>] [<host>]\n#/ Restores a GitHub instance from local backup snapshots. The <host> is the\n#/ hostname or IP of the GitHub instance. The <host> may be omitted when\n#/ the GHE_RESTORE_HOST config variable is set in backup.config. When a <host>\n#/ argument is provided, it always overrides the configured restore host.\n#/\n#/ Options:\n#/   -f                Don't prompt for confirmation before restoring.\n#/   -c                Restore appliance settings and license in addition to\n#/                     datastores. Settings are not restored by default to\n#/                     prevent overwriting different configuration on the\n#/                     restore host.\n#/   -s <snapshot-id>  Restore from the snapshot with the given id. Available\n#/                     snapshots may be listed under the data directory.\n#/   -v                Enable verbose output.\n#/\n#/ Note that the host must be reachable and your SSH key must be setup as\n#/ described in the following help article:\n#/\n#/ <https://enterprise.github.com/help/articles/adding-an-ssh-key-for-shell-access>\nset -e\n\n# Bring in the backup configuration.\ncd $(dirname \"$0\")/..\n. share/github-backup-utils/ghe-backup-config\n\n# Parse arguments\nrestore_settings=false\nforce=false\nwhile true; do\n    case \"$1\" in\n        -f|--force)\n            force=true\n            shift\n            ;;\n        -s)\n            snapshot_id=\"$(basename \"$2\")\"\n            shift 2\n            ;;\n        -c)\n            restore_settings=true\n            shift\n            ;;\n        -*)\n            echo \"Error: invalid argument: '$1'\" 1>&2\n            exit 1\n            ;;\n        *)\n            break\n            ;;\n    esac\ndone\n\n# Grab the host arg\nGHE_HOSTNAME=\"${1:-$GHE_RESTORE_HOST}\"\n\n# Hostname without any port suffix\nhostname=$(echo \"$GHE_HOSTNAME\" | cut -f 1 -d :)\n\n# Show usage with no <host>\n[ -z \"$GHE_HOSTNAME\" ] && print_usage\n\n# ghe-restore-snapshot-path validates it exists, determines what current is,\n# and if there's any problem, exit for us\nGHE_RESTORE_SNAPSHOT_PATH=\"$(ghe-restore-snapshot-path \"$snapshot_id\")\"\nGHE_RESTORE_SNAPSHOT=$(basename \"$GHE_RESTORE_SNAPSHOT_PATH\")\nexport GHE_RESTORE_SNAPSHOT\n\n# Figure out whether to use the tarball or rsync restore strategy based on the\n# strategy file written in the snapshot directory.\nGHE_BACKUP_STRATEGY=$(cat \"$GHE_RESTORE_SNAPSHOT_PATH/strategy\")\n\n# Perform a host-check and establish the remote version in GHE_REMOTE_VERSION.\nghe_remote_version_required \"$GHE_HOSTNAME\"\n\n# Keep other processes on the VM in the loop about the restore status.\n#\n# Other processes will look for these states:\n# \"restoring\" - restore is currently in progress\n# \"failed\"    - restore has failed\n# \"complete\"  - restore has completed successfully\nupdate_restore_status () {\n    if [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n        echo \"$1\" |\n        ghe-ssh \"$GHE_HOSTNAME\" -- \"sudo dd of='$GHE_REMOTE_DATA_USER_DIR/common/ghe-restore-status' 2>/dev/null\"\n    fi\n}\n\n# Figure out if this instance has been configured or is entirely new.\ninstance_configured=false\nif ghe-ssh \"$GHE_HOSTNAME\" -- \\\n    \"[ -f '$GHE_REMOTE_DATA_DIR/enterprise/dna.json' -o \\\n       -f '$GHE_REMOTE_ROOT_DIR/etc/github/configured' ]\"; then\n    instance_configured=true\nelif [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n    restore_settings=true\nfi\n\n# Figure out if this instance is in a replication pair\nif ghe-ssh \"$GHE_HOSTNAME\" -- \"ghe-repl-status -r 2>/dev/null\" \\\n  | grep -Eq \"replica|primary\"; then\n  instance_configured=true\n  echo \"WARNING: Restoring to a server with replication enabled interrupts replication.\"\n  echo \"         You will need to reconfigure replication after the restore completes.\"\nfi\n\n# Prompt to verify the restore host given is correct. Restoring overwrites\n# important data on the destination appliance that cannot be recovered. This is\n# mostly to prevent accidents where the backup host is given to restore instead\n# of a separate restore host since they're used in such close proximity.\nif $instance_configured && ! $force; then\n    echo\n    echo \"WARNING: All data on GitHub Enterprise appliance $hostname ($GHE_REMOTE_VERSION)\"\n    echo \"         will be overwritten with data from snapshot ${GHE_RESTORE_SNAPSHOT}.\"\n    echo \"Please verify that this is the correct restore host before continuing.\"\n    printf \"Type 'yes' to continue: \"\n\n    while read -r response; do\n        case $response in\n            yes|Yes|YES)\n                break\n                ;;\n            '')\n                printf \"Type 'yes' to continue: \"\n                ;;\n            *)\n                echo \"Restore aborted.\" 1>&2\n                exit 1\n                ;;\n        esac\n    done\n    echo\nfi\n\n# Log restore start message locally and in /var/log/syslog on remote instance\necho \"Starting restore of $GHE_HOSTNAME from snapshot $GHE_RESTORE_SNAPSHOT\"\nghe_remote_logger \"Starting restore from $(hostname) / snapshot $GHE_SNAPSHOT_TIMESTAMP ...\"\n\n# Update remote restore state file and setup failure trap\ntrap \"update_restore_status failed\" EXIT\nupdate_restore_status \"restoring\"\n\n# Verify the host has been fully configured at least once if when running\n# against v11.10.x appliances and the -c option wasn't specified.\nif [ \"$GHE_VERSION_MAJOR\" -le 1 ] && ! $restore_settings && ! $instance_configured; then\n    echo \"Error: $hostname not configured.\" 1>&2\n    echo \"Please visit https://$hostname/setup/settings to configure base appliance settings before continuing.\" 1>&2\n    exit 1\nfi\n\n# Restoring Elasticsearch to 11.10.3x via rsync requires GNU tar\nif [ \"$GHE_VERSION_MAJOR\" -le 1 ] && [ \"$GHE_BACKUP_STRATEGY\" = \"rsync\" ]; then\n    if ! tar --version | grep GNU >/dev/null; then\n        if ! command -v gtar >/dev/null 2>&1; then\n            echo \"GNU tar is required.  Aborting.\" >&2\n            exit 1\n        fi\n    fi\nfi\n\n# Make sure the GitHub appliance is in maintenance mode.\nif $instance_configured; then\n    if ! ghe-maintenance-mode-status \"$GHE_HOSTNAME\"; then\n        echo \"Error: $GHE_HOSTNAME must be put in maintenance mode before restoring. Aborting.\" 1>&2\n        exit 1\n    fi\nfi\n\n# Restore settings and license if restoring to an unconfigured appliance or when\n# specified manually.\nif $restore_settings; then\n    ghe-restore-settings \"$GHE_HOSTNAME\"\nfi\n\n# Make sure mysql and elasticsearch are prep'd and running before restoring into\n# appliances v2.x or greater. These services will not have been started on appliances\n# that have not been configured yet.\nif [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n    echo \"sudo ghe-service-ensure-mysql && sudo ghe-service-ensure-elasticsearch\" |\n    ghe-ssh \"$GHE_HOSTNAME\" -- /bin/sh 1>&3\nfi\n\n# Remove temporary 2.2 storage migration directory if it exists\necho \"if [ -d /data/user/repositories-nw-backup ]; then sudo rm -rf /data/user/repositories-nw-backup; fi\" |\nghe-ssh \"$GHE_HOSTNAME\" -- /bin/sh 1>&3\n\necho \"Restoring Git repositories ...\"\nghe-restore-repositories-${GHE_BACKUP_STRATEGY} \"$GHE_HOSTNAME\" 1>&3\n\necho \"Restoring GitHub Pages ...\"\nghe-restore-pages-${GHE_BACKUP_STRATEGY} \"$GHE_HOSTNAME\" 1>&3\n\nif [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n    echo \"Restoring asset attachments ...\"\n    ghe-restore-userdata alambic_assets \"$GHE_HOSTNAME\" 1>&3\n\n    echo \"Restoring hook deliveries ...\"\n    ghe-restore-userdata hookshot \"$GHE_HOSTNAME\" 1>&3\nfi\n\necho \"Restoring MySQL database ...\"\ngzip -dc \"$GHE_RESTORE_SNAPSHOT_PATH/mysql.sql.gz\" | ghe-ssh \"$GHE_HOSTNAME\" -- 'ghe-import-mysql' 1>&3\n\necho \"Restoring Redis database ...\"\nghe-ssh \"$GHE_HOSTNAME\" -- 'ghe-import-redis' < \"$GHE_RESTORE_SNAPSHOT_PATH/redis.rdb\" 1>&3\n\necho \"Restoring SSH authorized keys ...\"\nghe-ssh \"$GHE_HOSTNAME\" -- 'ghe-import-authorized-keys' < \"$GHE_RESTORE_SNAPSHOT_PATH/authorized-keys.json\" 1>&3\n\necho \"Restoring Elasticsearch indices ...\"\nghe-restore-es-${GHE_BACKUP_STRATEGY} \"$GHE_HOSTNAME\" 1>&3\n\n# Restart an already running memcached to reset the cache after restore\nif [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n    echo \"Restarting memcached ...\" 1>&3\n    echo \"sudo restart -q memcached 2>/dev/null || true\" |\n        ghe-ssh \"$GHE_HOSTNAME\" -- /bin/sh\nfi\n\n# When restoring to a host that has already been configured, kick off a\n# config run to perform data migrations.\nif $instance_configured; then\n  echo \"Configuring storage ...\"\n  if [ \"$GHE_VERSION_MAJOR\" -ge 2 ]; then\n    ghe-ssh \"$GHE_HOSTNAME\" -- \"sudo ghe-config-apply --full\" 1>&3\n  else\n    echo \"   This will take several minutes to complete...\"\n    ghe-ssh \"$GHE_HOSTNAME\" -- \"sudo enterprise-configure\" 1>&3 2>&3\n  fi\nfi\n\n# Update the remote status to \"complete\". This has to happen before importing\n# ssh host keys because subsequent commands will fail due to the host key\n# changing otherwise.\ntrap \"\" EXIT\nupdate_restore_status \"complete\"\n\n# Log restore complete message in /var/log/syslog on remote instance\nghe_remote_logger \"Completed restore from $(hostname) / snapshot ${GHE_SNAPSHOT_TIMESTAMP}.\"\n\necho \"Restoring SSH host keys ...\"\nghe-ssh \"$GHE_HOSTNAME\" -- 'ghe-import-ssh-host-keys' < \"$GHE_RESTORE_SNAPSHOT_PATH/ssh-host-keys.tar\" 1>&3\n\necho \"Completed restore of $GHE_HOSTNAME from snapshot $GHE_RESTORE_SNAPSHOT\"\necho \"Visit https://$hostname/setup/settings to review appliance configuration.\"\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":75,"column":0},"end":{"row":75,"column":0}},"properties":{"type":"selection","editorId":10,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/lildude/github/backup-utils/bin/ghe-restore","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"20ec84e32590c8422ca6b13dbf8ce73d4669b025","preferredLineEnding":null,"deserializer":"TextBuffer","version":2},{"text":"#!/bin/sh\n# Usage: . ghe-backup-config\n# GitHub Enterprise backup shell configuration.\n#\n# This file is sourced by the various utilities under bin and share/github-backup-utils to\n# load in backup configuration and ensure things are configured properly.\n#\n# All commands should start with the following:\n#\n#     cd $(dirname \"$0\")/../..\n#     . share/github-backup-utils/ghe-backup-config\n#\n\n# Assume the current directory is the root. This should be fine so long as all\n# scripts source us in according to the instructions above.\nGHE_BACKUP_ROOT=\"$(pwd)\"\n\n# Get the version from the version file.\nBACKUP_UTILS_VERSION=\"$(cat share/github-backup-utils/version)\"\n\n# Add the bin and share/github-backup-utils dirs to PATH\nPATH=\"$GHE_BACKUP_ROOT/bin:$GHE_BACKUP_ROOT/share/github-backup-utils:$PATH\"\n\n# The backup config file. This may be set in the environment.\n: ${GHE_BACKUP_CONFIG:=\"$GHE_BACKUP_ROOT/backup.config\"}\n\n# Parse out -v (verbose) argument\nif [ \"$1\" = \"-v\" ]; then\n    GHE_VERBOSE=true\n    shift\nfi\nexport GHE_VERBOSE\n\n# If verbose logging is enabled, redirect fd 3 to stdout; otherwise, redirect it\n# to /dev/null. Write verbose output to fd 3.\nif [ -n \"$GHE_VERBOSE\" ]; then\n    exec 3>&1\nelse\n    exec 3>/dev/null\nfi\n\n# Save off GHE_HOSTNAME from the environment since we want it to override the\n# backup.config value when set.\nGHE_HOSTNAME_PRESERVE=\"$GHE_HOSTNAME\"\n\n# Source in the backup config file from the local working copy location first\n# and then falling back to the system location.\nconfig_found=false\nfor f in \"$GHE_BACKUP_CONFIG\" \"/etc/github-backup-utils/backup.config\"; do\n    if [ -f \"$f\" ]; then\n        GHE_BACKUP_CONFIG=\"$f\"\n        . \"$GHE_BACKUP_CONFIG\"\n        config_found=true\n        break\n    fi\ndone\n\n# Check that the config file exists before we source it in.\nif ! $config_found; then\n    echo \"Error: No backup configuration file found. Tried:\" 1>&2\n    echo \" - $GHE_BACKUP_CONFIG\" 1>&2\n    echo \" - /etc/github-backup-utils/backup.config\" 1>&2\n    exit 2\nfi\n\n# Restore saved off hostname.\n[ -n \"$GHE_HOSTNAME_PRESERVE\" ] && GHE_HOSTNAME=\"$GHE_HOSTNAME_PRESERVE\"\n\n# Check that the GHE hostname is set.\nif [ -z \"$GHE_HOSTNAME\" ]; then\n    echo \"Error: GHE_HOSTNAME not set in config file.\" 1>&2\n    exit 2\nfi\n\n# Check that the data directory is set and create it if it doesn't exist.\nif [ ! -d \"$GHE_DATA_DIR\" ]; then\n    echo \"Creating the backup data directory ...\" 1>&3\n    mkdir -p \"$GHE_DATA_DIR\"\nfi\n\n# Set some defaults if needed.\n: ${GHE_NUM_SNAPSHOTS:=10}\n\n# Generate a backup timestamp if one has not already been generated.\n# We export the variable so the process group shares the same value.\n: ${GHE_SNAPSHOT_TIMESTAMP:=$(date +\"%Y%m%dT%H%M%S\")}\nexport GHE_SNAPSHOT_TIMESTAMP\n\n# Set the current snapshot directory to <data-dir>/<timestamp>. This is where\n# all backups should be written for the current invocation.\nGHE_SNAPSHOT_DIR=\"$GHE_DATA_DIR\"/\"$GHE_SNAPSHOT_TIMESTAMP\"\n\n# The root filesystem location. This must be used so that tests can override\n# the root as a local directory location.\n: ${GHE_REMOTE_ROOT_DIR:=\"\"}\n\n# The root location of persistent data and applications on the remote side. This\n# is always \"/data\" for GitHub instances. Use of this variable allows\n# the location to be overridden in tests.\n: ${GHE_REMOTE_DATA_DIR:=\"/data\"}\n\n# The root location of user data stores such as git repositories, pages sites,\n# elasticsearch indices, etc. This is \"/data\" under 1.x filesystem layouts and\n# \"/data/user\" under the 2.x filesystem layout. The location is adjusted\n# dynamically in ghe_remote_version_config() immediately after obtaining the\n# remote version. Utilities that transfer data in and out of the appliance\n# should use this variable to ensure proper behavior under different versions.\n: ${GHE_REMOTE_DATA_USER_DIR:=\"$GHE_REMOTE_DATA_DIR\"}\n\n# The location of the license file on the remote side. This is always\n# \"/data/enterprise/enterprise.ghl\" for GitHub instances. Use of this variable\n# allows the location to be overridden in tests.\n: ${GHE_REMOTE_LICENSE_FILE:=\"$GHE_REMOTE_DATA_DIR/enterprise/enterprise.ghl\"}\n\n# The legacy location of the metadata file on the remote side. Only used if\n# the newer \"ghe-negotiate-version\" script cannot be found or fails. This was\n# \"/data/enterprise/metadata.json\" for GitHub instances. Use of this variable\n# allows the location to be overridden in tests.\n: ${GHE_REMOTE_METADATA_FILE:=\"$GHE_REMOTE_DATA_DIR/enterprise/chef_metadata.json\"}\n\n# CPU and IO throttling to keep backups and restores from thrashing around.\n: ${GHE_NICE:=\"nice -n 19\"}\n: ${GHE_IONICE:=\"ionice -c 3\"}\n\n# The number of seconds to wait for in progress git-gc processes to complete\n# before starting the sync of git data. See share/github-backup-utils/ghe-backup-repositories-rsync\n# for more information. Default: 10 minutes.\n: ${GHE_GIT_COOLDOWN_PERIOD:=600}\n\n# Set \"true\" to get verbose logging of all ssh commands on stderr\n: ${GHE_VERBOSE_SSH:=false}\n\n\n###############################################################################\n### Dynamic remote version config\n\n# Adjusts remote paths based on the version of the remote appliance. This is\n# called immediately after the remote version is obtained by\n# ghe_remote_version_required(). Child processes inherit the values set here.\nghe_remote_version_config () {\n    if [ \"$GHE_VERSION_MAJOR\" -gt 1 ]; then\n        GHE_REMOTE_DATA_USER_DIR=\"$GHE_REMOTE_DATA_DIR/user\"\n    fi\n    export GHE_REMOTE_DATA_DIR GHE_REMOTE_DATA_USER_DIR\n    export GHE_REMOTE_LICENSE_FILE GHE_REMOTE_METADATA_FILE\n}\n\n###############################################################################\n### Utility functions\n\n# Function to print usage embedded in a script's opening doc comments.\nprint_usage () {\n    grep '^#/' <\"$0\" | cut -c 4-\n    exit ${1:-1}\n}\n\n# Check for a \"--help\" arg and show usage\nfor a in \"$@\"; do\n    if [ \"$a\" = \"--help\" ]; then\n        print_usage\n    fi\ndone\n\n# If we don't have a readlink command, parse ls -l output.\nif ! type readlink 1>/dev/null 2>&1; then\n    readlink () {\n        if [ -x \"$1\" ]; then\n            ls -ld \"$1\" | sed 's/.*-> //'\n        else\n            return 1\n        fi\n    }\nfi\n\n# Run ghe-host-check and establish the version of the remote GitHub instance in\n# the exported GHE_REMOTE_VERSION variable. If the remote version has already\n# been established then don't perform the host check again. Utilities in share/github-backup-utils\n# that need the remote version should use this function instead of calling\n# ghe-host-check directly to reduce ssh roundtrips. The top-level ghe-backup and\n# ghe-restore commands establish the version for all subcommands.\nghe_remote_version_required () {\n    if [ -z \"$GHE_REMOTE_VERSION\" ]; then\n        _out=$(ghe-host-check \"$@\")\n        echo \"$_out\"\n\n        # override hostname w/ ghe-host-check output because the port could have\n        # been autodetected to 122.\n        GHE_HOSTNAME=$(echo \"$_out\" | sed 's/Connect \\(.*:[0-9]*\\) OK.*/\\1/')\n        export GHE_HOSTNAME\n\n        GHE_REMOTE_VERSION=$(echo \"$_out\" | sed 's/.*(\\(.*\\))/\\1/')\n        export GHE_REMOTE_VERSION\n\n        ghe_parse_remote_version \"$GHE_REMOTE_VERSION\"\n        ghe_remote_version_config \"$GHE_REMOTE_VERSION\"\n    fi\n    true\n}\n\n# Parse major, minor, and patch parts of the remote appliance version and store\n# in GHE_VERSION_MAJOR, GHE_VERSION_MINOR, and GHE_VERSION_PATCH variables. All\n# parts are numeric. This is called automatically from\n# ghe_remote_version_required so shouldn't be used directly.\n#\n# Scripts use these variables to alter behavior based on what's supported on the\n# appliance version. The version parts are modified somewhat to make dealing\n# with the 11.10.x version scheme more sane. The \"11.10\" part of the remote\n# version is normalized to \"1.0\" so \"11.10.340\" would have parts \"1.0.340\".\nghe_parse_remote_version () {\n    GHE_VERSION_MAJOR=$(echo \"${1#v}\" | cut -f 1 -d .)\n    GHE_VERSION_MINOR=$(echo \"$1\"     | cut -f 2 -d .)\n    GHE_VERSION_PATCH=$(echo \"$1\"     | cut -f 3 -d .)\n    GHE_VERSION_PATCH=${GHE_VERSION_PATCH%%[a-zA-Z]*}\n\n    if [ \"$GHE_VERSION_MAJOR.$GHE_VERSION_MINOR\" = \"11.10\" ]; then\n        GHE_VERSION_MAJOR=1\n        GHE_VERSION_MINOR=0\n    fi\n\n    export GHE_VERSION_MAJOR GHE_VERSION_MINOR GHE_VERSION_PATCH\n}\n\n# Parses the <host> part out of a \"<host>:<port>\" or just \"<host>\" string.\n# This is used primarily to break hostspecs with non-standard ports down for\n# rsync commands.\nssh_host_part () {\n    [ \"${1##*:}\" = \"$1\" ] && echo \"$1\" || echo \"${1%:*}\"\n}\n\n# Parses the <port> part out of a \"<host>:<port>\" or just \"<host>\" string.\n# This is used primarily to break hostspecs with non-standard ports down for\n# rsync commands.\nssh_port_part () {\n    [ \"${1##*:}\" = \"$1\" ] && echo 22 || echo \"${1##*:}\"\n}\n\n# Usage: ghe_remote_logger <message>...\n# Log a message to /var/log/syslog on the remote instance.\n# Note: Use sparingly. Remote logging requires an ssh connection per invocation.\nghe_remote_logger () {\n    echo \"$@\" |\n    ghe-ssh \"$GHE_HOSTNAME\" -- logger -t backup-utils || true\n}\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":14},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/lildude/github/backup-utils/share/github-backup-utils/ghe-backup-config","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7d67681f8fc8b38998bc5e306cc922ff0f40f4d7","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":10,"softTabs":true,"displayBuffer":{"id":11,"softWrapped":true,"scrollTop":1384,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lildude/github/backup-utils/bin/ghe-restore","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":14,"softTabs":true,"displayBuffer":{"id":15,"softWrapped":true,"scrollTop":2158,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lildude/github/backup-utils/share/github-backup-utils/ghe-backup-config","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/lildude/github/backup-utils/bin/ghe-restore","focused":false,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-shellscript","language-hyperlink","language-todo"],"deserializer":"Workspace"},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"packageStates":{"metrics":{"sessionLength":371920},"fuzzy-finder":{"/Users/lildude/github/backup-utils/bin/ghe-restore":1441774909613,"/Users/lildude/github/backup-utils/share/github-backup-utils/ghe-backup-config":1441774807041},"keybinding-resolver":{},"tree-view":{"directoryExpansionStates":{"/Users/lildude/github/backup-utils":{"isExpanded":true,"entries":{"bin":{"isExpanded":true,"entries":{}},"debian":{"isExpanded":false,"entries":{}},"script":{"isExpanded":true,"entries":{}},"share":{"isExpanded":false,"entries":{}},"test":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/lildude/github/backup-utils/share","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200},"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["hostname","hook"],"replaceHistory":[],"pathsHistory":[]},"linter":{"scope":"File"},"tabs":[{}]}}