{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1362,"height":834,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"paths":["/Users/lildude/github/github-services"],"buffers":[{"text":"class Service::Bugzilla < Service\n  string   :server_url, :username, :integration_branch\n  password :password\n  boolean  :central_repository\n  boolean  :comment_on_resolution\n  white_list :server_url, :username, :integration_branch\n # svc = Service::Bugzilla.new(:push, {'server_url' => 'http://192.168.2.206:8080/bugzilla', 'username' => 'ghe-admin@ghe.dev', 'password' => 'passworD1', 'central_repository' => 1, 'comment_on_resolution' => 0}, {\"after\"=>\"a47fd41f3aa4610ea527dcc1669dfdb9c15c5425\", \"ref\"=>\"refs/heads/master\", \"before\"=>\"4c8124ffcf4039d292442eeccabdeca5af5c5017\", \"compare\"=>\"http://github.com/mojombo/grit/compare/4c8124f...a47fd41\", \"repository\"=>{\"name\"=>\"grit\", \"url\"=>\"http://github.com/mojombo/grit\", \"owner\"=>{\"name\"=>\"mojombo\", \"email\"=>\"tom@mojombo.com\"}, \"master_branch\"=>\"master\", \"default_branch\"=>\"master\"}, \"pusher\"=>{\"name\"=>\"rtomayko\"}, \"commits\"=>[{\"distinct\"=>true, \"removed\"=>[], \"message\"=>msg, \"added\"=>[], \"timestamp\"=>\"2007-10-10T00:11:02-07:00\", \"modified\"=>[\"lib/grit/grit.rb\", \"test/helper.rb\", \"test/test_grit.rb\"], \"url\"=>\"http://github.com/mojombo/grit/commit/06f63b43050935962f84fe54473a7c5de7977325\", \"author\"=>{\"name\"=>\"Tom Preston-Werner\", \"email\"=>\"tom@mojombo.com\"}, \"id\"=>\"06f63b43050935962f84fe54473a7c5de7977326\"}]})\n  def receive_push\n    # Check for settings\n    if data['server_url'].to_s.empty?\n      raise_config_error \"Bugzilla url not set\"\n    end\n    if data['username'].to_s.empty?\n      raise_config_error \"username not set\"\n    end\n    if data['password'].to_s.empty?\n      raise_config_error \"password not set\"\n    end\n\n    # Don't operate on these commits unless this is our \"integration\" (i.e. main) branch,\n    # as defined by the user. If no integration_branch is set, we operate on all commits.\n    return unless integration_branch?\n\n    # Post comments on all bugs identified in commits\n    repository = payload['repository']['url'].to_s\n    commits = payload['commits'].collect{|c| Commit.new(c)}\n    bug_commits = sort_commits(commits)\n    bugs_to_close = []\n    bug_commits.each_pair do | bug, commits |\n      if central_repository?\n        # Only include first line of message if commit already mentioned\n        commit_messages = commits.collect{|c| c.comment(bug_mentions_commit?(bug, c))}\n      else\n        # Don't include commits already mentioned\n        commit_messages = commits.select{|c| !bug_mentions_commit?(bug, c)}.collect{|c| c.comment}\n      end\n\n      if commits.collect{|c| c.closes}.any?\n        bugs_to_close << bug\n      end\n\n      if ((bugs_to_close.include? bug) && (comment_on_resolution?))\n        # Comment and close the bug in one step\n        post_bug_comment(bug, repository, commit_messages, branch.to_s, comment_on_resolution?)\n        # Remove bug from list that need closing\n        bugs_to_close.delete(bug)\n      else\n        post_bug_comment(bug, repository, commit_messages, branch.to_s)\n      end\n    end\n\n    # Close bugs\n    if central_repository?\n      close_bugs(bugs_to_close)\n    end\n  end\n\n  def central_repository?\n    config_boolean_true?('central_repository')\n  end\n\n  def comment_on_resolution?\n    config_boolean_true?('comment_on_resolution')\n  end\n\n  # Name of the branch for this payload; nil if it isn't branch-related.\n  def branch\n    return @branch if defined?(@branch)\n\n    matches = payload['ref'].match(/^refs\\/heads\\/(.*)$/)\n    @branch = matches ? matches[1] : nil\n  end\n\n  def integration_branch?\n    data['integration_branch'].to_s.empty? or data['integration_branch'].to_s == branch.to_s\n  end\n\n  attr_writer :xmlrpc_client # Can define own server for testing\n  def xmlrpc_client\n    # XMLRPC client to communicate with Bugzilla server\n    @xmlrpc_client ||= begin\n      client = XMLRPC::Client.new2(\"#{data['server_url'].to_s}/xmlrpc.cgi\")\n\n      # Workaround for XMLRPC bug - https://bugs.ruby-lang.org/issues/8182\n      # Should no longer be needed when we start running Ruby 2.2\n      client.http_header_extra = {\"accept-encoding\" => \"identity\"}\n\n      result = client.call('User.login', {'login' => data['username'].to_s, 'password' => data['password'].to_s})\n      @token = result['token']\n      client\n    rescue XMLRPC::FaultException\n      raise_config_error \"Invalid login details\"\n    rescue SocketError, RuntimeError\n      raise_config_error \"Invalid server url\"\n    end\n  end\n\n  def xmlrpc_authed_call(method, args)\n    # Add token parameter to XMLRPC call if one was received when logging into Bugzilla\n    args['Bugzilla_token'] = @token if not @token.nil?\n    xmlrpc_client.call(method, args)\n  end\n\n  def sort_commits(commits)\n    # Sort commits into a hash of arrays based on bug id\n    bug_commits = Hash.new{|k,v| k[v] = []}\n    commits.each do |commit|\n      commit.bugs.each do |bug|\n        bug_commits[bug] << commit\n      end\n    end\n    return bug_commits\n  end\n\n  def bug_mentions_commit?(bug_id, commit)\n    # Check if a bug already mentions a commit.\n    # This is to avoid repeating commits that have\n    # been pushed to another person's repository\n    result = xmlrpc_authed_call('Bug.comments', {'ids' => [bug_id]})\n    all_comments = result['bugs'][\"#{bug_id}\"]['comments'].collect{|c| c['text']}.join(\"\\n\")\n    all_comments.include? commit.id\n  rescue XMLRPC::FaultException, RuntimeError\n    # Bug doesn't exist or Bugzilla version doesn't support getting comments\n    false\n  end\n\n  def post_bug_comment(bug, repository, commit_messages, branch_name, close = nil)\n    # Post a comment on an individual bug\n    if commit_messages.length == 0\n      return\n    end\n    branch_str = branch_name.empty? ? \"\" : \"#{branch_name} at \"\n    if commit_messages.length > 1\n      message = \"Commits pushed to #{branch_str}#{repository}\\n\\n\"\n    else\n      message = \"Commit pushed to #{branch_str}#{repository}\\n\\n\"\n    end\n    message += commit_messages.join(\"\\n\\n\")\n    begin\n      if close\n        xmlrpc_authed_call('Bug.update', {'ids' => bug, 'status' => 'RESOLVED', 'resolution' => 'FIXED', 'comment' => {'body' => message}})\n      else\n        xmlrpc_authed_call('Bug.add_comment', {'id' => bug, 'comment' => message})\n      end\n    rescue XMLRPC::FaultException\n      # Bug doesn't exist or user can't add comments, do nothing\n    rescue RuntimeError\n      raise_config_error \"Bugzilla version doesn't support adding comments\"\n    end\n  end\n\n  def close_bugs(bug_ids)\n    if bug_ids.length > 0\n      begin\n        xmlrpc_authed_call('Bug.update', {'ids' => bug_ids, 'status' => 'RESOLVED', 'resolution' => 'FIXED'})\n      rescue XMLRPC::FaultException, RuntimeError\n        # Bug doesn't exist, user can't close bug, or version < 4.0 that doesn't support Bug.update.\n        # Do nothing\n      end\n    end\n  end\n\n  class Commit\n    attr_reader :closes, :bugs, :url, :id\n\n    def initialize(commit_hash)\n      @id = commit_hash['id'].to_s\n      @url = commit_hash['url'].to_s\n      @message = commit_hash['message'].to_s\n      @closes = false\n\n      # Get the list of bugs mentioned in this commit message\n      message_re = /((close|fix|address)e?(s|d)? )?(ticket|bug|tracker item|issue)s?:? *([\\d ,\\+&#and]+)/i\n      if (@message =~ message_re) != nil\n        if $1\n          @closes = true\n        end\n        @bugs = $5.split(/[^\\d]+/).select{|b| !b.empty?}.collect{|b| Integer(b)}\n      else\n        @bugs = []\n      end\n    end\n\n    def comment(first_line_only=false)\n      # Comment contents for a commit\n      output = \"#{@url}\\n\"\n      if first_line_only\n        output += @message.lines.first.strip\n      else\n        output += @message.strip\n      end\n      return output\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[6,0],[7,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":4,"goalBufferRange":null,"autoscroll":true,"preserveFolds":true},"deserializer":"Marker"},"21":{"id":21,"range":[[62,24],[62,48]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"24":{"id":24,"range":[[62,25],[62,47]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"123":{"id":123,"range":[[154,107],[154,107]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"164":{"id":164,"range":[[151,24],[151,24]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"729":{"id":729,"range":[[45,28],[45,32]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"935":{"id":935,"range":[[42,0],[42,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"1035":{"id":1035,"range":[[140,0],[140,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"1066":{"id":1066,"range":[[140,0],[140,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"1251":{"id":1251,"range":[[40,0],[41,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"1431":{"id":1431,"range":[[4,0],[4,33]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1432":{"id":1432,"range":[[6,0],[6,1039]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1433":{"id":1433,"range":[[36,0],[36,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1434":{"id":1434,"range":[[40,0],[48,9]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1435":{"id":1435,"range":[[61,0],[64,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1436":{"id":1436,"range":[[126,0],[126,82]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1437":{"id":1437,"range":[[139,0],[143,9]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1445":{"id":1445,"range":[[4,0],[4,33]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1446":{"id":1446,"range":[[6,0],[6,1039]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1447":{"id":1447,"range":[[36,0],[36,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1448":{"id":1448,"range":[[40,0],[48,9]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1449":{"id":1449,"range":[[61,0],[64,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1450":{"id":1450,"range":[[126,0],[126,82]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"},"1451":{"id":1451,"range":[[139,0],[143,9]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/lildude/github/github-services/lib/services/bugzilla.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"432503a55283a27d8203c768bb1bb6a830e3aacc","deserializer":"TextBuffer"},{"text":"# Represents a single triggered Service call.  Each Service tracks the event\n# type, the configuration data, and the payload for the current call.\nclass Service\n  UTF8 = \"UTF-8\".freeze\n  class Contributor < Struct.new(:value)\n    def self.contributor_types\n      @contributor_types ||= []\n    end\n\n    def self.inherited(contributor_type)\n      contributor_types << contributor_type\n      super\n    end\n\n    def self.create(type, keys)\n      klass = contributor_types.detect { |struct| struct.contributor_type == type }\n      if klass\n        Array(keys).map do |key|\n          klass.new(key)\n        end\n      else\n        raise ArgumentError, \"Invalid Contributor type #{type.inspect}\"\n      end\n    end\n\n    def to_contributor_hash(key)\n      {:type => self.class.contributor_type, key => value}\n    end\n  end\n\n  class EmailContributor < Contributor\n    def self.contributor_type\n      :email\n    end\n\n    def to_hash\n      to_contributor_hash(:address)\n    end\n  end\n\n  class GitHubContributor < Contributor\n    def self.contributor_type\n      :github\n    end\n\n    def to_hash\n      to_contributor_hash(:login)\n    end\n  end\n\n  class TwitterContributor < Contributor\n    def self.contributor_type\n      :twitter\n    end\n\n    def to_hash\n      to_contributor_hash(:login)\n    end\n  end\n\n  class WebContributor < Contributor\n    def self.contributor_type\n      :web\n    end\n\n    def to_hash\n      to_contributor_hash(:url)\n    end\n  end\n\n  dir = File.expand_path '../service', __FILE__\n  Dir[\"#{dir}/events/helpers/*.rb\"].each do |helper|\n    require helper\n  end\n  Dir[\"#{dir}/events/*.rb\"].each do |helper|\n    require helper\n  end\n\n  ALL_EVENTS = %w[\n    commit_comment create delete download follow fork fork_apply gist gollum\n    issue_comment issues member public pull_request push team_add watch\n    pull_request_review_comment status release deployment deployment_status\n  ].sort\n\n  class << self\n    attr_accessor :root, :env, :host\n\n    %w(development test production staging fi).each do |m|\n      define_method \"#{m}?\" do\n        env == m\n      end\n    end\n\n    # The SHA1 of the commit that was HEAD when the process started. This is\n    # used in production to determine which version of the app is deployed.\n    #\n    # Returns the 40 char commit SHA1 string.\n    def current_sha\n      @current_sha ||=\n        `cd #{root}; git rev-parse HEAD 2>/dev/null || echo unknown`.\n        chomp.freeze\n    end\n\n    attr_writer :current_sha\n\n    # Returns the Service instance if it responds to this event, or nil.\n    def receive(event, data, payload = nil)\n      new(event, data, payload).receive\n    end\n\n    def load_services\n      require File.expand_path(\"../services/http_post\", __FILE__)\n      path = File.expand_path(\"../services/**/*.rb\", __FILE__)\n      Dir[path].each { |lib| require(lib) }\n    end\n\n    # Tracks the defined services.\n    #\n    # Returns an Array of Service Classes.\n    def services\n      @services ||= []\n    end\n\n    # Gets the default events that this Service will listen for.  This defines\n    # the default event configuration when Hooks are created on GitHub.  By\n    # default, GitHub Hooks will only send `push` events.\n    #\n    # Returns an Array of Strings (or Symbols).\n    def default_events(*events)\n      if events.empty?\n        @default_events ||= [:push]\n      else\n        @default_events = events.flatten\n      end\n    end\n\n    # Gets a list of events support by the service. Should be a superset of\n    # default_events.\n    def supported_events\n      return ALL_EVENTS.dup if method_defined? :receive_event\n      ALL_EVENTS.select { |event| method_defined? \"receive_#{event}\" }\n    end\n\n    # Gets the current schema for the data attributes that this Service\n    # expects.  This schema is used to generate the GitHub repository admin\n    # interface.  The attribute types loosely to HTML input elements.\n    #\n    # Example:\n    #\n    #   class FooService < Service\n    #     string :token\n    #   end\n    #\n    #   FooService.schema\n    #   # => [[:string, :token]]\n    #\n    # Returns an Array of [Symbol attribute type, Symbol attribute name] tuples.\n    def schema\n      @schema ||= []\n    end\n\n    # Public: Adds the given attributes as String attributes in the Service's\n    # schema.\n    #\n    # Example:\n    #\n    #   class FooService < Service\n    #     string :token\n    #   end\n    #\n    #   FooService.schema\n    #   # => [[:string, :token]]\n    #\n    # *attrs - Array of Symbol attribute names.\n    #\n    # Returns nothing.\n    def string(*attrs)\n      add_to_schema :string, attrs\n    end\n\n    # Public: Adds the given attributes as Password attributes in the Service's\n    # schema.\n    #\n    # Example:\n    #\n    #   class FooService < Service\n    #     password :token\n    #   end\n    #\n    #   FooService.schema\n    #   # => [[:password, :token]]\n    #\n    # *attrs - Array of Symbol attribute names.\n    #\n    # Returns nothing.\n    def password(*attrs)\n      add_to_schema :password, attrs\n    end\n\n    # Public: Adds the given attributes as Boolean attributes in the Service's\n    # schema.\n    #\n    # Example:\n    #\n    #   class FooService < Service\n    #     boolean :digest\n    #   end\n    #\n    #   FooService.schema\n    #   # => [[:boolean, :digest]]\n    #\n    # *attrs - Array of Symbol attribute names.\n    #\n    # Returns nothing.\n    def boolean(*attrs)\n      add_to_schema :boolean, attrs\n    end\n\n    # Public: get a list of attributes that are approved for logging.  Don't\n    # add things like tokens or passwords here.\n    #\n    # Returns an Array of String attribute names.\n    def white_listed\n      @white_listed ||= []\n    end\n\n    def white_list(*attrs)\n      attrs.each do |attr|\n        white_listed << attr.to_s\n      end\n    end\n\n\n    # Adds the given attributes to the Service's data schema.\n    #\n    # type  - A Symbol specifying the type: :string, :password, :boolean.\n    # attrs - Array of Symbol attribute names.\n    #\n    # Returns nothing.\n    def add_to_schema(type, attrs)\n      attrs.each do |attr|\n        schema << [type, attr.to_sym]\n      end\n    end\n\n    # Gets the official title of this Service.  This is used in any\n    # user-facing documentation regarding the Service.\n    #\n    # Returns a String.\n    def title(value = nil)\n      if value\n        @title = value\n      else\n        @title ||= begin\n          hook = name.dup\n          hook.sub! /.*:/, ''\n          hook\n        end\n      end\n    end\n\n    # Sets the official title of this Service.\n    #\n    # title - The String title.\n    #\n    # Returns nothing.\n    attr_writer :title\n\n    # Gets the name that identifies this Service type.  This is a\n    # short string that is used to uniquely identify the service internally.\n    #\n    # Returns a String.\n    def hook_name(value = nil)\n      if value\n        @hook_name = value\n      else\n        @hook_name ||= begin\n          hook = name.dup\n          hook.downcase!\n          hook.sub! /.*:/, ''\n          hook\n        end\n      end\n    end\n\n    # Sets the uniquely identifying name for this Service type.\n    #\n    # hook_name - The String name.\n    #\n    # Returns a String.\n    attr_writer :hook_name\n\n    attr_reader :url, :logo_url\n\n    def url(value = nil)\n      if value\n        @url = value\n      else\n        @url\n      end\n    end\n\n    def logo_url(value = nil)\n      if value\n        @logo_url = value\n      else\n        @logo_url\n      end\n    end\n\n    def supporters\n      @supporters ||= []\n    end\n\n    def maintainers\n      @maintainers ||= []\n    end\n\n    def supported_by(values)\n      values.each do |contributor_type, value|\n        supporters.push(*Contributor.create(contributor_type, value))\n      end\n    end\n\n    def maintained_by(values)\n      values.each do |contributor_type, value|\n        maintainers.push(*Contributor.create(contributor_type, value))\n      end\n    end\n\n    # Public: Gets the Hash of secret configuration options.  These are set on\n    # the GitHub servers and never committed to git.\n    #\n    # Returns a Hash.\n    def secrets\n      @secrets ||= begin\n        jabber = ENV['SERVICES_JABBER'].to_s.split(\"::\")\n        twitter = ENV['SERVICES_TWITTER'].to_s.split(\"::\")\n\n        { 'jabber' => {'user' => jabber[0], 'password' => jabber[1] },\n          'boxcar' => {'apikey' => ENV['SERVICES_BOXCAR'].to_s},\n          'twitter' => {'key' => twitter[0], 'secret' => twitter[1]},\n          'bitly' => {'key' => ENV['SERVICES_BITLY'].to_s}\n        }\n      end\n    end\n\n    # Public: Gets the Hash of email configuration options.  These are set on\n    # the GitHub servers and never committed to git.\n    #\n    # Returns a Hash.\n    def email_config\n      @email_config ||= begin\n        hash = (File.exist?(email_config_file) && YAML.load_file(email_config_file)) || {}\n        EMAIL_KEYS.each do |key|\n          env_key = \"EMAIL_SMTP_#{key.upcase}\"\n          value = ENV[env_key]\n          if value && value != ''\n            hash[key] = value\n          end\n        end\n        hash\n      end\n    end\n    EMAIL_KEYS = %w(address port domain authentication user_name password\n                    enable_starttls_auto openssl_verify_mode enable_logging\n                    noreply_address)\n\n    # Gets the path to the secret configuration file.\n    #\n    # Returns a String path.\n    def secret_file\n      @secret_file ||= File.expand_path(\"../../config/secrets.yml\", __FILE__)\n    end\n\n    # Gets the path to the email configuration file.\n    #\n    # Returns a String path.\n    def email_config_file\n      @email_config_file ||= File.expand_path('../../config/email.yml', __FILE__)\n    end\n\n    def objectify(hash)\n      struct = OpenStruct.new\n      hash.each do |key, value|\n        struct.send(\"#{key}=\", value.is_a?(Hash) ? objectify(value) : value)\n      end\n      struct\n    end\n\n    # Sets the path to the secrets configuration file.\n    #\n    # secret_file - String path.\n    #\n    # Returns nothing.\n    attr_writer :secret_file\n\n    # Sets the default private configuration data for all Services.\n    #\n    # secrets - Configuration Hash.\n    #\n    # Returns nothing.\n    attr_writer :secrets\n\n    # Sets the path to the email configuration file.\n    #\n    # email_config_file - The String path.\n    #\n    # Returns nothing.\n    attr_writer :email_config_file\n\n    # Sets the default email configuration data for all Services.\n    #\n    # email_config - Email configuration Hash.\n    #\n    # Returns nothing.\n    attr_writer :email_config\n\n    # Binds the current Service to the Sinatra App.\n    #\n    # Returns nothing.\n    def inherited(svc)\n      Service.services << svc\n      super\n    end\n  end\n\n  # Determine #root from this file's location\n  self.root ||= File.expand_path('../..', __FILE__)\n  self.host ||= `hostname -s`.chomp\n\n  # Determine #env from the environment\n  self.env ||= ENV['RACK_ENV'] || ENV['GEM_STRICT'] ? 'production' : 'development'\n\n  # Public: Gets the configuration data for this Service instance.\n  #\n  # Returns a Hash.\n  attr_reader :data\n\n  # Public: Gets the unique payload data for this Service instance.\n  #\n  # Returns a Hash.\n  attr_reader :payload\n\n  # Public: Gets the identifier for the Service's event.\n  #\n  # Returns a Symbol.\n  attr_reader :event\n\n  # Optional String unique identifier for this exact event.\n  attr_accessor :delivery_guid\n\n  # Sets the Faraday::Connection for this Service instance.\n  #\n  # http - New Faraday::Connection instance.\n  #\n  # Returns a Faraday::Connection.\n  attr_writer :http\n\n  # Sets the private configuration data.\n  #\n  # secrets - Configuration Hash.\n  #\n  # Returns nothing.\n  attr_writer :secrets\n\n  # Sets the email configuration data.\n  #\n  # email_config - Email configuration Hash.\n  #\n  # Returns nothing.\n  attr_writer :email_config\n\n  # Sets the path to the SSL Certificate Authority file.\n  #\n  # ca_file - String path.\n  #\n  # Returns nothing.\n  attr_writer :ca_file\n\n  attr_reader :event_method\n\n  attr_reader :http_calls\n\n  attr_reader :remote_calls\n\n  def initialize(event = :push, data = {}, payload = nil)\n    helper_name = \"#{event.to_s.classify}Helpers\"\n    if Service.const_defined?(helper_name)\n      @helper = Service.const_get(helper_name)\n      extend @helper\n    end\n\n    @event = event.to_sym\n    @data = data || {}\n    @payload = payload || sample_payload\n    @event_method = [\"receive_#{event}\", \"receive_event\"].detect do |method|\n      respond_to?(method)\n    end\n    @http = @secrets = @email_config = nil\n    @http_calls = []\n    @remote_calls = []\n  end\n\n  # Boolean fields as either nil, \"0\", or \"1\".\n  def config_boolean_true?(boolean_field)\n    data[boolean_field].to_i == 1\n  end\n\n  def config_boolean_false?(boolean_field)\n    !config_boolean_true?(boolean_field)\n  end\n\n  def respond_to_event?\n    !@event_method.nil?\n  end\n\n  # Public: Shortens the given URL with git.io.\n  #\n  # url - String URL to be shortened.\n  #\n  # Returns the String URL response from git.io.\n  def shorten_url(url)\n    res = http_post(\"http://git.io\", :url => url)\n    if res.status == 201\n      res.headers['location']\n    else\n      url\n    end\n  rescue TimeoutError\n    url\n  end\n\n  # Public: Makes an HTTP GET call.\n  #\n  # url     - Optional String URL to request.\n  # params  - Optional Hash of GET parameters to set.\n  # headers - Optional Hash of HTTP headers to set.\n  #\n  # Examples\n  #\n  #   http_get(\"http://github.com\")\n  #   # => <Faraday::Response>\n  #\n  #   # GET http://github.com?page=1\n  #   http_get(\"http://github.com\", :page => 1)\n  #   # => <Faraday::Response>\n  #\n  #   http_get(\"http://github.com\", {:page => 1},\n  #     'Accept': 'application/json')\n  #   # => <Faraday::Response>\n  #\n  #   # Yield the Faraday::Response for more control.\n  #   http_get \"http://github.com\" do |req|\n  #     req.basic_auth(\"username\", \"password\")\n  #     req.params[:page] = 1\n  #     req.headers['Accept'] = 'application/json'\n  #   end\n  #   # => <Faraday::Response>\n  #\n  # Yields a Faraday::Request instance.\n  # Returns a Faraday::Response instance.\n  def http_get(url = nil, params = nil, headers = nil)\n    http.get do |req|\n      req.url(url)                if url\n      req.params.update(params)   if params\n      req.headers.update(headers) if headers\n      yield req if block_given?\n    end\n  end\n\n  # Public: Makes an HTTP POST call.\n  #\n  # url     - Optional String URL to request.\n  # body    - Optional String Body of the POST request.\n  # headers - Optional Hash of HTTP headers to set.\n  #\n  # Examples\n  #\n  #   http_post(\"http://github.com/create\", \"foobar\")\n  #   # => <Faraday::Response>\n  #\n  #   http_post(\"http://github.com/create\", \"foobar\",\n  #     'Accept': 'application/json')\n  #   # => <Faraday::Response>\n  #\n  #   # Yield the Faraday::Response for more control.\n  #   http_post \"http://github.com/create\" do |req|\n  #     req.basic_auth(\"username\", \"password\")\n  #     req.params[:page] = 1 # http://github.com/create?page=1\n  #     req.headers['Content-Type'] = 'application/json'\n  #     req.body = generate_json(:foo => :bar)\n  #   end\n  #   # => <Faraday::Response>\n  #\n  # Yields a Faraday::Request instance.\n  # Returns a Faraday::Response instance.\n  def http_post(url = nil, body = nil, headers = nil)\n    block = Proc.new if block_given?\n    http_method :post, url, body, headers, &block\n  end\n\n  # Public: Makes an HTTP call.\n  #\n  # method  - Symbol of the HTTP method.  Example: :put\n  # url     - Optional String URL to request.\n  # body    - Optional String Body of the POST request.\n  # headers - Optional Hash of HTTP headers to set.\n  #\n  # Examples\n  #\n  #   http_method(:put, \"http://github.com/create\", \"foobar\")\n  #   # => <Faraday::Response>\n  #\n  #   http_method(:put, \"http://github.com/create\", \"foobar\",\n  #     'Accept': 'application/json')\n  #   # => <Faraday::Response>\n  #\n  #   # Yield the Faraday::Response for more control.\n  #   http_method :put, \"http://github.com/create\" do |req|\n  #     req.basic_auth(\"username\", \"password\")\n  #     req.params[:page] = 1 # http://github.com/create?page=1\n  #     req.headers['Content-Type'] = 'application/json'\n  #     req.body = generate_json(:foo => :bar)\n  #   end\n  #   # => <Faraday::Response>\n  #\n  # Yields a Faraday::Request instance.\n  # Returns a Faraday::Response instance.\n  def http_method(method, url = nil, body = nil, headers = nil)\n    block = Proc.new if block_given?\n\n    check_ssl do\n      http.send(method) do |req|\n        req.url(url)                if url\n        req.headers.update(headers) if headers\n        req.body = body             if body\n        block.call req if block\n      end\n    end\n  end\n\n  # Public: Lazily loads the Faraday::Connection for the current Service\n  # instance.\n  #\n  # options - Optional Hash of Faraday::Connection options.\n  #\n  # Returns a Faraday::Connection instance.\n  def http(options = {})\n    @http ||= begin\n      config = self.class.default_http_options\n      config.each do |key, sub_options|\n        next if key == :adapter\n        sub_hash = options[key] ||= {}\n        sub_options.each do |sub_key, sub_value|\n          sub_hash[sub_key] ||= sub_value\n        end\n      end\n      options[:ssl][:ca_file] ||= ca_file\n\n      adapter = Array(options.delete(:adapter) || config[:adapter])\n      Faraday.new(options) do |b|\n        b.request(:url_encoded)\n        b.adapter *adapter\n        b.use(HttpReporter, self)\n      end\n    end\n  end\n\n  def self.default_http_options\n    @@default_http_options ||= {\n      :adapter => :net_http,\n      :request => {:timeout => 10, :open_timeout => 5},\n      :ssl => {:verify_depth => 5},\n      :headers => {}\n    }\n  end\n\n  # Passes HTTP response debug data to the HTTP callbacks.\n  def receive_http(env)\n    @http_calls << env\n  end\n\n  # Passes raw debug data to remote call callbacks.\n  def receive_remote_call(text)\n    @remote_calls << text\n  end\n\n  def receive(timeout = nil)\n    return unless respond_to_event?\n    timeout_sec = (timeout || 20).to_i\n    Service::Timeout.timeout(timeout_sec, TimeoutError) do\n      send(event_method)\n    end\n\n    self\n  rescue Service::ConfigurationError, Errno::EHOSTUNREACH, Errno::ECONNRESET, SocketError, Net::ProtocolError => err\n    if !err.is_a?(Service::Error)\n      err = ConfigurationError.new(err)\n    end\n    raise err\n  end\n\n  def generate_json(body)\n    JSON.generate(clean_for_json(body))\n  end\n\n  def clean_hash_for_json(hash)\n    new_hash = {}\n    hash.keys.each do |key|\n      new_hash[key] = clean_for_json(hash[key])\n    end\n    new_hash\n  end\n\n  def clean_array_for_json(array)\n    array.map { |value| clean_for_json(value) }\n  end\n\n  # overridden in Hookshot for proper UTF-8 transcoding with CharlockHolmes\n  def clean_string_for_json(str)\n    str.to_s.force_encoding(Service::UTF8)\n  end\n\n  def clean_for_json(value)\n    case value\n    when Hash then clean_hash_for_json(value)\n    when Array then clean_array_for_json(value)\n    when String then clean_string_for_json(value)\n    else value\n    end\n  end\n\n  # Public: Checks for an SSL error, and re-raises a Services configuration error.\n  #\n  # Returns nothing.\n  def check_ssl\n    yield\n  rescue OpenSSL::SSL::SSLError => e\n    raise_config_error \"Invalid SSL cert\"\n  end\n\n  # Public: Builds a log message for this Service request.  Respects the white\n  # listed attributes in the Service schema.\n  #\n  # Returns a String.\n  def log_message(status = 0)\n    \"[%s] %03d %s/%s %s\" % [Time.now.utc.to_s(:db), status,\n      self.class.hook_name, @event, generate_json(log_data)]\n  end\n\n  # Public: Builds a sanitized Hash of the Data hash without passwords.\n  #\n  # Returns a Hash.\n  def log_data\n    @log_data ||= self.class.white_listed.inject({}) do |hash, key|\n      if value = data[key]\n        hash.update key => sanitize_log_value(value)\n      else\n        hash\n      end\n    end\n  end\n\n  # Attempts to sanitize passwords out of URI strings.\n  #\n  # value - The String attribute value.\n  #\n  # Returns a sanitized String.\n  def sanitize_log_value(value)\n    string = value.to_s\n    string.strip!\n    if string =~ /^[a-z]+\\:\\/\\//\n      uri = Addressable::URI.parse(string)\n      uri.password = \"*\" * 8 if uri.password\n      uri.to_s\n    else\n      string\n    end\n  rescue Addressable::URI::InvalidURIError\n    string\n  end\n\n  # Public: Gets the Hash of secret configuration options.  These are set on\n  # the GitHub servers and never committed to git.\n  #\n  # Returns a Hash.\n  def secrets\n    @secrets || Service.secrets\n  end\n\n  # Public: Gets the Hash of email configuration options.  These are set on\n  # the GitHub servers and never committed to git.\n  #\n  # Returns a Hash.\n  def email_config\n    @email_config || Service.email_config\n  end\n\n  # Public: Raises a configuration error inside a service, and halts further\n  # processing.\n  #\n  # Raises a Service;:ConfigurationError.\n  def raise_config_error(msg = \"Invalid configuration\")\n    raise ConfigurationError, msg\n  end\n\n  def raise_missing_error(msg = \"Remote endpoint not found\")\n    raise MissingError, msg\n  end\n\n  # Gets the path to the SSL Certificate Authority certs.  These were taken\n  # from: http://curl.haxx.se/ca/cacert.pem\n  #\n  # Returns a String path.\n  def ca_file\n    @ca_file ||= File.expand_path('../../config/cacert.pem', __FILE__)\n  end\n\n  # Generates a sample payload for the current Service instance.\n  #\n  # Returns a Hash payload.\n  def sample_payload\n    @helper ? @helper.sample_payload : {}\n  end\n\n  def reportable_http_env(env, time)\n    {\n      :request => {\n        :url => env[:url].to_s,\n        :headers => env[:request_headers]\n      }, :response => {\n        :status => env[:status],\n        :headers => env[:response_headers],\n        :body => env[:body].to_s,\n        :duration => \"%.02fs\" % [Time.now - time]\n      },\n      :adapter => env[:adapter]\n    }\n  end\n\n  # Raised when an unexpected error occurs during service hook execution.\n  class Error < StandardError\n    attr_reader :original_exception\n    def initialize(message, original_exception=nil)\n      original_exception = message if message.kind_of?(Exception)\n      @original_exception = original_exception\n      super(message)\n    end\n  end\n\n  class TimeoutError < Timeout::Error\n  end\n\n  # Raised when a service hook fails due to bad configuration. Services that\n  # fail with this exception may be automatically disabled.\n  class ConfigurationError < Error\n  end\n\n  class MissingError < Error\n  end\n\n  class HttpReporter < Faraday::Response::Middleware\n    def initialize(app, service = nil)\n      super(app)\n      @service = service\n      @time = Time.now\n    end\n\n    def on_complete(env)\n      @service.receive_http(@service.reportable_http_env(env, @time))\n    end\n  end\nend\n\nrequire 'timeout'\nbegin\n  require 'system_timer'\n  Service::Timeout = SystemTimer\nrescue LoadError\n  Service::Timeout = Timeout\nend\n","markers":{"markers":{"1":{"id":1,"range":[[505,25],[505,25]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":24,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/lildude/github/github-services/lib/service.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0a82f394d08bcd1fd0a8216167aab91636e7e2e5","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":true,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":1,"tokenizedBuffer":{"bufferPath":"/Users/lildude/github/github-services/lib/services/bugzilla.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":24,"softTabs":true,"displayBuffer":{"id":25,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lildude/github/github-services/lib/service.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemUri":"/Users/lildude/github/github-services/lib/services/bugzilla.rb","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-hyperlink","language-todo"],"deserializer":"Workspace"},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"packageStates":{"metrics":{"sessionLength":943790170},"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["bug 2","central_repo","config_boolean_true","aws"],"replaceHistory":["vm"],"pathsHistory":["vm"]},"fuzzy-finder":{"/Users/lildude/github/github-services/lib/services/bugzilla.rb":1420105860051,"/Users/lildude/github/github-services/lib/service.rb":1419162224942},"keybinding-resolver":{},"tree-view":{"directoryExpansionStates":{"lib":{"services":{}}},"selectedPath":"/Users/lildude/github/github-services/lib/services/bugzilla.rb","hasFocus":false,"attached":true,"scrollLeft":7,"scrollTop":4050,"width":200}}}